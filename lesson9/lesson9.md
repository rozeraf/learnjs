### План Урока 9: Специализированные типы: Tuples, Unknown и Never

**Цель:** Научиться использовать кортежи для строго типизированных массивов фиксированной длины, `unknown` для безопасной работы с неизвестными данными и `never` для создания исчерпывающе безопасных проверок.

**Концепции, которые мы затронем:**

1.  **Кортежи (Tuples):**
    *   Это массивы **фиксированной длины**, где для **каждой позиции** известен свой тип.
    *   **Отличие от `string[]`:** `string[]` — это массив *любой* длины, содержащий *только* строки. Кортеж `[string, number]` — это массив, где **первый** элемент — строка, **второй** — число, и их всего два.
    *   **Пример:** `let user: [string, number] = ["Алекс", 25];`
    *   **Связь с прошлым:** Помнишь, наш `useState` возвращал `[() => T, (newValue: T) => void]`? Это и был кортеж!

2.  **`unknown` — Безопасный `any`:**
    *   Тип для переменных, чей тип мы не знаем заранее (например, ответ от сервера).
    *   **Отличие от `any`:** TypeScript **запрещает** делать что-либо с переменной типа `unknown`, пока ты явно не проверишь её тип (с помощью `typeof`, `instanceof` и т.д.). Это заставляет писать безопасный код.
    *   **Пример:**
        ```ts
        let data: unknown = JSON.parse('{"a": 1}');
        if (typeof data === 'object' && data !== null) {
          // Только теперь можно работать с data как с объектом
        }
        ```

3.  **`never` — Тип, которого не бывает:**
    *   `never` используется для обозначения ситуаций, которые **никогда не должны произойти**.
    *   **Два главных случая:**
        1.  Функция, которая **всегда** выбрасывает ошибку (`throw new Error(...)`).
        2.  Функция с бесконечным циклом (`while (true)`).
    *   **Главная польза:** Создание **исчерпывающих проверок (exhaustive checks)** в `switch`, чтобы компилятор заставлял тебя обрабатывать все возможные варианты.

---

**Практика:**

1.  **Задача "Кортеж для координат":**
    *   Создай псевдоним типа `type Point = [number, number];` для 2D-координат.
    *   Напиши функцию `logPoint(p: Point)`, которая принимает кортеж и выводит `"Координаты: X=p[0], Y=p[1]"`.
    *   Создай несколько `Point` и передай их в функцию.

2.  **Задача "Безопасный парсинг":**
    *   Напиши функцию `processApiResponse(response: unknown)`.
    *   Внутри функции, используя проверки `typeof` и `Array.isArray`, обработай разные типы `response`:
        *   Если это `string`, выведи её в верхнем регистре.
        *   Если это `number`, выведи его квадрат.
        *   Если это `Array`, выведи его длину.
        *   В остальных случаях выводи "Неизвестный тип данных".

3.  **Задача "Исчерпывающая проверка с `never`":**
    *   Создай литеральный тип `type Shape = "circle" | "square";`.
    *   Напиши функцию `getArea(shape: Shape)`, которая использует `switch`.
    *   В `case "circle"` и `case "square"` просто возвращай какое-нибудь число.
    *   В блоке `default` сделай следующее:
        ```ts
        default:
          const _exhaustiveCheck: never = shape;
          return _exhaustiveCheck;
        ```
    *   **Эксперимент:** Попробуй добавить в тип `Shape` новое значение `"triangle"`. Ты должен увидеть, как TypeScript сразу же подсветит ошибку в блоке `default`, заставляя тебя добавить новый `case` для треугольника.

---

**Инструменты:** `bun run`, `bunx tsc`.

**GitHub:** Закоммитить `lesson9/lesson9.ts` и `lesson9/lesson9.md`.
