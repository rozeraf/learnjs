### План Урока 7: `this` и Контекст вызова

**Цель:** Досконально разобраться, как определяется значение `this` в JavaScript, и научиться управлять им с помощью методов `call`, `apply` и `bind`.

**Концепции, которые мы затронем:**

1.  **Динамическая природа `this`:**
    *   Повторение главного правила: `this` определяется в момент **вызова** функции, а не её создания.

2.  **4 основных правила определения `this`:**
    *   **1. Глобальный вызов:** `myFunction()` → `this` равен `window` (в браузере) или `undefined` (в 'use strict' / модулях).
    *   **2. Вызов как метода:** `myObject.myMethod()` → `this` равен `myObject`.
    *   **3. Вызов через `new`:** `new MyClass()` → `this` равен новому созданному экземпляру.
    *   **4. Явное указание:** с помощью `call`, `apply`, `bind`.

3.  **Управление контекстом:**
    *   **`.call(thisArg, arg1, arg2, ...)`:** **Вызывает** функцию немедленно, "одалживая" ей `this` и передавая аргументы по одному.
    *   **`.apply(thisArg, [arg1, arg2, ...])`:** То же, что и `.call`, но аргументы передаются в виде **массива**.
    *   **`.bind(thisArg)`:** **Не вызывает** функцию, а **возвращает новую функцию**, у которой `this` навсегда "привязан" к `thisArg`.

4.  **`this` в стрелочных функциях (`=>`):**
    *   Повторение: у стрелочных функций **нет своего `this`**. Они берут его из **внешней области видимости**, где были созданы. Это их главное отличие и преимущество.

---

**Практика:**

1.  **"Потеря контекста" и её решение:**
    *   Создай класс `Counter` с приватным свойством `count` и методом `increment()`, который увеличивает `count` и выводит его в консоль.
    *   Создай экземпляр `const counter = new Counter()`.
    *   "Оторви" метод: `const standaloneIncrement = counter.increment;`.
    *   Вызови `standaloneIncrement()`. Ты должен получить ошибку.
    *   Создай "привязанную" версию метода с помощью `.bind()`: `const boundIncrement = counter.increment.bind(counter);`.
    *   Вызови `boundIncrement()`. Теперь всё должно работать.

2.  **"Одалживание" метода с помощью `.call()`:**
    *   Создай два объекта: `user1 = { name: "Иван" }` и `user2 = { name: "Мария" }`.
    *   Создай **одну** глобальную функцию `sayName() { console.log(this.name); }`.
    *   Используя `.call()`, вызови функцию `sayName` сначала в контексте `user1`, а затем в контексте `user2`.

3.  **`this` в колбэках (классическая проблема):**
    *   Создай класс `Timer` с свойством `message` и методом `start()`.
    *   Внутри `start()` используй `setTimeout(function() { ... }, 1000)`, который через секунду попытается вывести `this.message`.
    *   Ты увидишь, что `this` "потерялся".
    *   Исправь проблему, заменив `function() { ... }` на **стрелочную функцию** `() => { ... }`. Объясни, почему это сработало.

---

**Инструменты:** `bun run`, `bunx tsc`.

**GitHub:** Закоммитить `lesson7/lesson7.ts` и `lesson7/lesson7.md`.
